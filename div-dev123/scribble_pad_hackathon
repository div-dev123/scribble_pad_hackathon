{
  "metadata": {
    "name": "New JSNB",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "// Create canvas and context\nconst canvas = document.createElement('canvas');\nconst ctx = canvas.getContext('2d');\ncanvas.width = 1000;\ncanvas.height = 700;\ndocument.body.appendChild(canvas);\n\n// Constants\nconst TWO_PI = Math.PI * 2;\nconst PI = Math.PI;\nconst width = 1000;\nconst height = 700;\nconst rows = 70;\nconst cols = 100;\nconst viewAngle = 3.0 * Math.PI / 4.0;\nconst defaultColor = { r: 255, g: 12, b: 100 };\nconst qR = Math.PI / 30;\nlet game, player;\nlet scaleX = 10;\nlet scaleY = 10;\nlet topLeftX = 5;\nlet topLeftY = 5;\nlet maxDiagonal = 1000;\nlet looping = true;\n\n// Utility functions\nfunction random(min, max) {\n    return Math.random() * (max - min) + min;\n}\n\nfunction floor(n) {\n    return Math.floor(n);\n}\n\nfunction dist(x1, y1, x2, y2) {\n    return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n}\n\n// Player class\nclass Player {\n    constructor(x, y, dir, options) {\n        this.x = x;\n        this.y = y;\n        this.dir = dir;\n        this.color = options ? (options.color ? options.color : defaultColor) : defaultColor;\n        this.maxHealth = 100;\n        this.health = this.maxHealth;\n        this.lastAttackTime = 0;\n        this.isAttacking = false;\n        this.attackRange = 2;\n        this.attackCooldown = 300;\n        this.damage = 35;\n    }\n\n    modDir() {\n        this.dir = this.dir + 2 * TWO_PI;\n        this.dir = this.dir - (Math.floor(this.dir / TWO_PI) * TWO_PI);\n        if (this.dir < 0) this.dir = this.dir + TWO_PI;\n    }\n\n    rotate(v) {\n        this.dir = this.dir + v;\n        this.modDir();\n    }\n\n    rotateRight() {\n        this.rotate(-qR);\n    }\n\n    rotateLeft() {\n        this.rotate(qR);\n    }\n\n    move(vx, vy) {\n        this.x += vx;\n        this.y += vy;\n    }\n\n    moveForward() {\n        if (this.dir <= PI / 8) this.move(1, 0);\n        else if (this.dir <= PI / 8 + PI / 4) this.move(1, 1);\n        else if (this.dir <= PI / 8 + PI / 2) this.move(0, 1);\n        else if (this.dir <= PI / 8 + 3 * PI / 4) this.move(-1, 1);\n        else if (this.dir <= PI / 8 + PI) this.move(-1, 0);\n        else if (this.dir <= PI / 8 + 5 * PI / 4) this.move(-1, -1);\n        else if (this.dir <= PI / 8 + 3 * PI / 2) this.move(0, -1);\n        else if (this.dir <= PI / 8 + 7 * PI / 4) this.move(1, -1);\n        else this.move(1, 0);\n    }\n\n    moveBackward() {\n        let originalDir = this.dir;\n        this.dir += PI;\n        this.modDir();\n        this.moveForward();\n        this.dir = originalDir;\n    }\n\n    moveLeft() {\n        let originalDir = this.dir;\n        this.dir += (-PI / 2);\n        this.modDir();\n        this.moveForward();\n        this.dir = originalDir;\n    }\n\n    moveRight() {\n        let originalDir = this.dir;\n        this.dir += (PI / 2);\n        this.modDir();\n        this.moveForward();\n        this.dir = originalDir;\n    }\n\n     attack() {\n        const currentTime = Date.now();\n        if (currentTime - this.lastAttackTime >= this.attackCooldown && !this.isAttacking) {\n            this.isAttacking = true;\n            this.lastAttackTime = currentTime;\n            \n            // Clear attack state after animation\n            setTimeout(() => {\n                this.isAttacking = false;\n            }, 150);\n            \n            return true;\n        }\n        return false;\n    }\n\n\n    takeDamage(amount) {\n        this.health = Math.max(0, this.health - amount);\n        return this.health <= 0;\n    }\n\n    heal(amount) {\n        this.health = Math.min(this.maxHealth, this.health + amount);\n    }\n}\n\nclass Enemy {\n    constructor(x, y, type) {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.patrolPoints = [];\n        this.currentPatrolIndex = 0;\n        this.moveSpeed = 0.05;\n        this.detectionRange = 5;\n        this.animationPhase = 0;\n\n        switch(type) {\n            case 'stationary':\n                this.color = { r: 255, g: 50, b: 50 };\n                this.maxHealth = 50;\n                this.damage = 10;\n                this.attackRange = 2;\n                break;\n            case 'patrol':\n                this.color = { r: 50, g: 255, b: 50 };\n                this.maxHealth = 75;\n                this.damage = 15;\n                this.attackRange = 2.5;\n                break;\n            case 'chase':\n                this.color = { r: 50, g: 50, b: 255 };\n                this.maxHealth = 100;\n                this.damage = 20;\n                this.attackRange = 3;\n                break;\n        }\n\n        this.health = this.maxHealth;\n        this.attackCooldown = 1000;\n        this.lastAttackTime = 0;\n        this.isAttacking = false;\n    }\n\n    update(player) {\n        switch (this.type) {\n            case 'patrol':\n                this.patrol();\n                break;\n            case 'chase':\n                if (this.canSeePlayer(player)) {\n                    this.chase(player);\n                }\n                break;\n        }\n\n        const distanceToPlayer = dist(this.x, this.y, player.x, player.y);\n        if (distanceToPlayer <= this.attackRange) {\n            this.attackPlayer(player);\n        }\n    }\n\n    canSeePlayer(player) {\n        const distance = dist(this.x, this.y, player.x, player.y);\n        return distance <= this.detectionRange;\n    }\n\n    attackPlayer(player) {\n        const currentTime = Date.now();\n        if (currentTime - this.lastAttackTime >= this.attackCooldown) {\n            this.isAttacking = true;\n            this.lastAttackTime = currentTime;\n            player.takeDamage(this.damage);\n            \n            setTimeout(() => {\n                this.isAttacking = false;\n            }, 200);\n        }\n    }\n\n    takeDamage(amount) {\n        this.health = Math.max(0, this.health - amount);\n        return this.health <= 0;\n    }\n\n    patrol() {\n        if (this.patrolPoints.length < 2) return;\n        \n        const target = this.patrolPoints[this.currentPatrolIndex];\n        const dx = target.x - this.x;\n        const dy = target.y - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance < 0.1) {\n            this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;\n        } else {\n            const newX = this.x + (dx / distance) * this.moveSpeed;\n            const newY = this.y + (dy / distance) * this.moveSpeed;\n            \n            if (!bumpingIntoWall(Math.floor(newX), Math.floor(newY))) {\n                this.x = newX;\n                this.y = newY;\n            }\n        }\n    }\n\n    chase(player) {\n        const dx = player.x - this.x;\n        const dy = player.y - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance > 0.1) {\n            const newX = this.x + (dx / distance) * this.moveSpeed;\n            const newY = this.y + (dy / distance) * this.moveSpeed;\n            \n            if (!bumpingIntoWall(Math.floor(newX), Math.floor(newY))) {\n                this.x = newX;\n                this.y = newY;\n            }\n        }\n    }\n}\n\nclass Game {\n    constructor(width, height, rows, cols) {\n        this.width = width;\n        this.height = height;\n        this.cols = cols;\n        this.rows = rows;\n        this.scaleX = this.width / this.cols;\n        this.scaleY = this.height / this.rows;\n        this.design = [];\n        this.player = undefined;\n        this.enemies = [];\n        \n        for (let i = 0; i < this.rows; i++) {\n            let row = [];\n            for (let j = 0; j < this.cols; j++) {\n                row.push(0);\n            }\n            this.design.push(row);\n        }\n    }\n\n     update() {\n        // Update enemy states and handle collisions\n        for (let i = this.enemies.length - 1; i >= 0; i--) {\n            const enemy = this.enemies[i];\n            enemy.update(this.player);\n            \n            // Check if enemy is dead\n            if (enemy.health <= 0) {\n                this.enemies.splice(i, 1);\n                continue;\n            }\n            \n            // Improved collision handling with push-back\n            const distanceToPlayer = dist(enemy.x, enemy.y, this.player.x, this.player.y);\n            if (distanceToPlayer < 1.5) { // Slightly larger collision radius\n                // Calculate push direction\n                const angle = Math.atan2(this.player.y - enemy.y, this.player.x - enemy.x);\n                const pushDistance = 0.3; // Reduced push distance for smoother interaction\n                \n                // Push both player and enemy away from each other\n                const newPlayerX = this.player.x + Math.cos(angle) * pushDistance;\n                const newPlayerY = this.player.y + Math.sin(angle) * pushDistance;\n                const newEnemyX = enemy.x - Math.cos(angle) * pushDistance;\n                const newEnemyY = enemy.y - Math.sin(angle) * pushDistance;\n                \n                // Only apply movement if new positions are valid\n                if (!this.bumpingIntoWall(Math.floor(newPlayerX), Math.floor(newPlayerY))) {\n                    this.player.x = newPlayerX;\n                    this.player.y = newPlayerY;\n                }\n                if (!this.bumpingIntoWall(Math.floor(newEnemyX), Math.floor(newEnemyY))) {\n                    enemy.x = newEnemyX;\n                    enemy.y = newEnemyY;\n                }\n            }\n        }\n\n        // Improved attack handling\n        if (this.player.isAttacking) {\n            const attackArc = Math.PI / 2; // 90-degree attack arc\n            const attackRange = this.player.attackRange;\n            \n            for (const enemy of this.enemies) {\n                const distanceToEnemy = dist(enemy.x, enemy.y, this.player.x, this.player.y);\n                const angleToEnemy = Math.atan2(enemy.y - this.player.y, enemy.x - this.player.x);\n                let angleDiff = angleToEnemy - this.player.dir;\n                \n                // Normalize angle difference\n                while (angleDiff > Math.PI) angleDiff -= TWO_PI;\n                while (angleDiff < -Math.PI) angleDiff += TWO_PI;\n\n                // Check if enemy is within attack range and angle\n                if (distanceToEnemy <= attackRange && Math.abs(angleDiff) < attackArc / 2) {\n                    enemy.takeDamage(this.player.damage);\n                    \n                    // Visual feedback - push enemy back slightly when hit\n                    const knockbackDistance = 0.5;\n                    const newX = enemy.x + Math.cos(angleToEnemy) * knockbackDistance;\n                    const newY = enemy.y + Math.sin(angleToEnemy) * knockbackDistance;\n                    \n                    if (!this.bumpingIntoWall(Math.floor(newX), Math.floor(newY))) {\n                        enemy.x = newX;\n                        enemy.y = newY;\n                    }\n                }\n            }\n        }\n\n        // Check for player death\n        if (this.player.health <= 0) {\n            this.handlePlayerDeath();\n        }\n\t \n\t }\n    // Helper method to check wall collisions\n    bumpingIntoWall(x, y) {\n        return this.design[y]?.[x] === 1;\n    }\n\n\n    handlePlayerDeath() {\n        let px, py;\n        let safeTries = 1000;\n        while (safeTries--) {\n            px = floor(random(0, cols - 1));\n            py = floor(random(0, rows - 1));\n            if (!bumpingIntoWall(px, py)) break;\n        }\n        this.player.x = px;\n        this.player.y = py;\n    }\n\n    addEnemy(enemy) {\n        this.enemies.push(enemy);\n    }\n\n    place(y, x, locations) {\n        if (!locations) this.design[y][x] = 1;\n        else for (let v of locations) {\n            this.design[v.y][v.x] = 1;\n        }\n    }\n\n    placeLine(y1, x1, y2, x2) {\n        if (y1 == y2) {\n            for (let j = Math.min(x1, x2); j <= Math.max(x1, x2); j++) {\n                this.place(y1, j);\n            }\n        } else if (x1 == x2) {\n            for (let i = Math.min(y1, y2); i <= Math.max(y1, y2); i++) {\n                this.place(i, x1);\n            }\n        }\n    }\n\n    addPlayer(player) {\n        this.player = player;\n    }\n    draw(topLeftX, topLeftY) {\n        // Draw game border\n        ctx.strokeStyle = 'white';\n        ctx.fillStyle = 'rgb(10,10,10)';\n        ctx.fillRect(topLeftX, topLeftY, this.width, this.height);\n        ctx.strokeRect(topLeftX, topLeftY, this.width, this.height);\n        \n        // Draw enemies\n        for (const enemy of this.enemies) {\n            ctx.fillStyle = `rgb(${enemy.color.r},${enemy.color.g},${enemy.color.b})`;\n            ctx.fillRect(\n                topLeftX + enemy.x * this.scaleX,\n                topLeftY + enemy.y * this.scaleY,\n                this.scaleX,\n                this.scaleY\n            );\n\n            // Draw enemy health bars when damaged\n            if (enemy.health < enemy.maxHealth) {\n                const enemyScreenX = topLeftX + enemy.x * this.scaleX;\n                const enemyScreenY = topLeftY + enemy.y * this.scaleY - 10;\n                const enemyHealthWidth = this.scaleX;\n                const enemyHealthHeight = 5;\n\n                // Background\n                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                ctx.fillRect(enemyScreenX, enemyScreenY, enemyHealthWidth, enemyHealthHeight);\n\n                // Health remaining\n                const enemyHealthPercentage = enemy.health / enemy.maxHealth;\n                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';\n                ctx.fillRect(enemyScreenX, enemyScreenY, enemyHealthWidth * enemyHealthPercentage, enemyHealthHeight);\n            }\n        }\n\n        // Draw walls\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.cols; j++) {\n                if (this.design[i][j] == 1) {\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(\n                        topLeftX + j * this.scaleX,\n                        topLeftY + i * this.scaleY,\n                        this.scaleX,\n                        this.scaleY\n                    );\n                }\n            }\n        }\n\n        // Draw player\n        if (this.player) {\n            ctx.fillStyle = `rgb(${this.player.color.r},${this.player.color.g},${this.player.color.b})`;\n            ctx.fillRect(\n                topLeftX + this.player.x * this.scaleX,\n                topLeftY + this.player.y * this.scaleY,\n                this.scaleX,\n                this.scaleY\n            );\n\n            // Draw view rays\n            ctx.strokeStyle = 'rgba(200,200,200,0.15)';\n            for (let angle = this.player.dir - viewAngle / 2; angle <= this.player.dir + viewAngle / 2; angle += PI / 200) {\n                let r = 50;\n                ctx.beginPath();\n                ctx.moveTo(\n                    topLeftX + this.player.x * this.scaleX + this.scaleX / 2,\n                    topLeftY + this.player.y * this.scaleY + this.scaleY / 2\n                );\n                ctx.lineTo(\n                    topLeftX + this.player.x * this.scaleX + this.scaleX / 2 + r * Math.cos(angle),\n                    topLeftY + this.player.y * this.scaleY + this.scaleY / 2 + r * Math.sin(angle)\n                );\n                ctx.stroke();\n            }\n        }\n\tif (player.isAttacking) {\n    // Draw attack arc\n    const arcStart = player.dir - Math.PI / 4;\n    const arcEnd = player.dir + Math.PI / 4;\n    ctx.beginPath();\n    ctx.arc(\n        topLeftX + player.x * scaleX + scaleX / 2,\n        topLeftY + player.y * scaleY + scaleY / 2,\n        player.attackRange * scaleX,\n        arcStart,\n        arcEnd\n    );\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n}\n        // Draw player health bar\n        const healthBarWidth = 200;\n        const healthBarHeight = 20;\n        const healthBarX = topLeftX;\n        const healthBarY = topLeftY - 30;\n\n        // Background\n        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);\n\n        // Health remaining\n        const healthPercentage = this.player.health / this.player.maxHealth;\n        ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';\n        ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercentage, healthBarHeight);\n\n        // Border\n        ctx.strokeStyle = 'white';\n        ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);\n    }\n}\n\n\n\n\n// Helper functions\nfunction bumpingIntoWall(x, y) {\n    return game.design[y][x] !== 0;\n}\nfunction inBounds(v, low, high) {\n    return v <= high && v >= low;\n}\nfunction setMap() {\n    const lines = [\n        [10, 20, 10, 60],\n        [10, 70, 10, 90],\n        [10, 20, 55, 20],\n        [55, 20, 55, 60],\n        [55, 60, 10, 60]\n    ];\n    for (let l of lines) {\n        game.placeLine(l[0], l[1], l[2], l[3]);\n    }\n}\nfunction advanceMove(move) {\n    let iX = player.x;\n    let iY = player.y;\n    move.call(player);\n    if (!inBounds(player.x, 0, cols - 1) || !inBounds(player.y, 0, rows - 1) || bumpingIntoWall(player.x, player.y)) {\n        player.x = iX;\n        player.y = iY;\n    }\n}\n// Setup game\nfunction setup() {\n    game = new Game(width * 0.2, height * 0.2, rows, cols);\n    maxDiagonal = dist(0, 0, width * 0.2, height * 0.2);\n    setMap();\n\n    // Create player\n    let px, py;\n    let safeTries = 1000;\n    while (safeTries--) {\n        px = floor(random(0, cols - 1));\n        py = floor(random(0, rows - 1));\n        if (!bumpingIntoWall(px, py)) break;\n    }\n    player = new Player(px, py, random(0, TWO_PI));\n    game.addPlayer(player);\n\n    // Add some enemies\n    addEnemies();\n}\n\nfunction isReachable(startX, startY, targetX, targetY) {\n    const visited = Array(rows).fill().map(() => Array(cols).fill(false));\n    const queue = [{x: startX, y: startY}];\n    visited[startY][startX] = true;\n\n    while (queue.length > 0) {\n        const current = queue.shift();\n        \n        if (current.x === targetX && current.y === targetY) {\n            return true;\n        }\n\n        // Check all adjacent cells (up, right, down, left)\n        const directions = [\n            {x: 0, y: 1}, {x: 1, y: 0},\n            {x: 0, y: -1}, {x: -1, y: 0}\n        ];\n\n        for (const dir of directions) {\n            const newX = current.x + dir.x;\n            const newY = current.y + dir.y;\n\n            if (inBounds(newX, 0, cols - 1) && \n                inBounds(newY, 0, rows - 1) && \n                !visited[newY][newX] && \n                !bumpingIntoWall(newX, newY)) {\n                \n                queue.push({x: newX, y: newY});\n                visited[newY][newX] = true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction addEnemies() {\n    // Function to find a valid spawn position\n    function findValidPosition() {\n        let safeTries = 1000;\n        while (safeTries--) {\n            const x = floor(random(0, cols - 1));\n            const y = floor(random(0, rows - 1));\n            \n            if (!bumpingIntoWall(x, y) && isReachable(player.x, player.y, x, y)) {\n                return { x, y };\n            }\n        }\n        return null;\n    }\n\n    // Add a stationary enemy in a reachable position\n    const stationaryPos = findValidPosition();\n    if (stationaryPos) {\n        const stationaryEnemy = new Enemy(stationaryPos.x, stationaryPos.y, 'stationary');\n        game.addEnemy(stationaryEnemy);\n    }\n\n    // Add a patrolling enemy with valid patrol points\n    const patrolPos = findValidPosition();\n    if (patrolPos) {\n        const patrollingEnemy = new Enemy(patrolPos.x, patrolPos.y, 'patrol');\n        \n        // Generate valid patrol points in a square pattern around spawn\n        const patrolPoints = [];\n        const patrolRadius = 5; // Size of patrol square\n        \n        const potentialPoints = [\n            { x: patrolPos.x - patrolRadius, y: patrolPos.y - patrolRadius },\n            { x: patrolPos.x + patrolRadius, y: patrolPos.y - patrolRadius },\n            { x: patrolPos.x + patrolRadius, y: patrolPos.y + patrolRadius },\n            { x: patrolPos.x - patrolRadius, y: patrolPos.y + patrolRadius }\n        ];\n\n        for (const point of potentialPoints) {\n            if (inBounds(point.x, 0, cols - 1) && \n                inBounds(point.y, 0, rows - 1) && \n                !bumpingIntoWall(point.x, point.y) &&\n                isReachable(patrolPos.x, patrolPos.y, point.x, point.y)) {\n                patrolPoints.push(point);\n            }\n        }\n\n        if (patrolPoints.length >= 2) {\n            patrollingEnemy.patrolPoints = patrolPoints;\n            game.addEnemy(patrollingEnemy);\n        }\n    }\n\n    // Add a chasing enemy in a reachable position\n    const chasePos = findValidPosition();\n    if (chasePos) {\n        const chasingEnemy = new Enemy(chasePos.x, chasePos.y, 'chase');\n        game.addEnemy(chasingEnemy);\n    }\n}\n\nEnemy.prototype.patrol = function() {\n    if (this.patrolPoints.length < 2) return;\n    \n    const target = this.patrolPoints[this.currentPatrolIndex];\n    const dx = target.x - this.x;\n    const dy = target.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    \n    if (distance < 0.1) {\n        this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;\n    } else {\n        const newX = this.x + (dx / distance) * this.moveSpeed;\n        const newY = this.y + (dy / distance) * this.moveSpeed;\n        \n        // Only move if new position is valid\n        if (!bumpingIntoWall(Math.floor(newX), Math.floor(newY))) {\n            this.x = newX;\n            this.y = newY;\n        }\n    }\n};\n\nEnemy.prototype.chase = function(player) {\n    const dx = player.x - this.x;\n    const dy = player.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    \n    if (distance > 0.1) {\n        const newX = this.x + (dx / distance) * this.moveSpeed;\n        const newY = this.y + (dy / distance) * this.moveSpeed;\n        \n        // Only move if new position is valid\n        if (!bumpingIntoWall(Math.floor(newX), Math.floor(newY))) {\n            this.x = newX;\n            this.y = newY;\n        }\n    }\n};\n\n// Main draw loop\nfunction draw() {\n    game.update();\n    ctx.fillStyle = 'rgb(22,22,22)';\n    ctx.fillRect(0, 0, width, height);\n    let dAngle = PI / 200;\n    let noOfDivisions = floor(viewAngle / dAngle);\n    let dWidth = width / noOfDivisions;\n    let divCount = 0;\n\n    // Update animation phase\n    const animationSpeed = 0.1;\n    for (const enemy of game.enemies) {\n        enemy.animationPhase = (enemy.animationPhase + animationSpeed) % (2 * Math.PI);\n    }\n\n    for (let angle = player.dir - viewAngle / 2; angle <= player.dir + viewAngle / 2; angle += dAngle) {\n        let wallDist = maxDiagonal;\n        let enemyInView = null;\n        let enemyDist = maxDiagonal;\n\n        // Check for walls\n        for (let r = 0.1; r < maxDiagonal + 0.1; r += 0.1) {\n            let xx = player.x + (r * Math.cos(angle)) / scaleX;\n            let yy = player.y + (r * Math.sin(angle)) / scaleY;\n            let floorX = Math.floor(xx);\n            let floorY = Math.floor(yy);\n\n            if (!(inBounds(floorX, 0, cols - 1) && inBounds(floorY, 0, rows - 1))) {\n                break;\n            }\n            else if (inBounds(floorX, 0, cols - 1) && inBounds(floorY, 0, rows - 1) && game.design[floorY][floorX] === 1) {\n                wallDist = dist(player.x, player.y, xx, yy);\n                break;\n            }\n        }\n\n        // Check for enemies in this ray\n        for (const enemy of game.enemies) {\n            const enemyAngleToPlayer = Math.atan2(enemy.y - player.y, enemy.x - player.x);\n            let angleDiff = angle - enemyAngleToPlayer;\n            \n            while (angleDiff > Math.PI) angleDiff -= TWO_PI;\n            while (angleDiff < -Math.PI) angleDiff += TWO_PI;\n\n            const tolerance = 0.1;\n            if (Math.abs(angleDiff) < tolerance) {\n                const d = dist(player.x, player.y, enemy.x, enemy.y);\n                if (d < wallDist && d < enemyDist) {\n                    enemyDist = d;\n                    enemyInView = enemy;\n                }\n            }\n        }\n\n        // Draw wall slice\n        let op = floor(255 / (Math.pow(wallDist, 3 / 2)));\n        ctx.fillStyle = `rgba(255,255,255,${op/255})`;\n        let cx = divCount * dWidth + dWidth / 2;\n        let cy = height / 2;\n        let w = dWidth;\n        let h = height * (2 / (wallDist * Math.pow(Math.cos(angle - player.dir), 0)));\n        ctx.fillRect(cx - w/2, cy - h/2, w, h);\n\n        // Draw enemy if visible with enhanced styling\n        if (enemyInView && enemyDist < wallDist) {\n    const enemyHeight = height * (2 / (enemyDist * Math.pow(Math.cos(angle - player.dir), 0)));\n    const enemyWidth = w * 1.2;\n    \n    const enemyX = cx - enemyWidth/2;\n    const enemyY = cy - enemyHeight/2;\n    \n    // Common dimensions for human shape\n    const headSize = enemyHeight * 0.2;\n    const bodyHeight = enemyHeight * 0.5;\n    const legHeight = enemyHeight * 0.3;\n    const shoulderWidth = enemyWidth * 0.8;\n    \n    switch(enemyInView.type) {\n        case 'stationary':\n            // Guard standing still\n            ctx.fillStyle = `rgba(${enemyInView.color.r},${enemyInView.color.g},${enemyInView.color.b},${0.8/(enemyDist)})`;\n            \n            // Head\n            ctx.beginPath();\n            ctx.arc(cx, enemyY + headSize, headSize, 0, Math.PI * 2);\n            ctx.fill();\n            \n            // Body\n            ctx.fillRect(cx - shoulderWidth/2, enemyY + headSize * 2, shoulderWidth, bodyHeight);\n            \n            // Arms (straight down)\n            ctx.fillRect(cx - shoulderWidth/2 - enemyWidth*0.1, enemyY + headSize * 2, enemyWidth*0.1, bodyHeight * 0.7);\n            ctx.fillRect(cx + shoulderWidth/2, enemyY + headSize * 2, enemyWidth*0.1, bodyHeight * 0.7);\n            \n            // Legs\n            ctx.fillRect(cx - shoulderWidth/4, enemyY + headSize * 2 + bodyHeight, shoulderWidth*0.2, legHeight);\n            ctx.fillRect(cx + shoulderWidth/4 - shoulderWidth*0.2, enemyY + headSize * 2 + bodyHeight, shoulderWidth*0.2, legHeight);\n            break;\n            \n        case 'patrol':\n            // Patrolling guard with swinging arms\n            const armSwing = Math.sin(enemyInView.animationPhase) * 0.2;\n            \n            ctx.fillStyle = `rgba(${enemyInView.color.r},${enemyInView.color.g},${enemyInView.color.b},${0.8/(enemyDist)})`;\n            \n            // Head\n            ctx.beginPath();\n            ctx.arc(cx, enemyY + headSize, headSize, 0, Math.PI * 2);\n            ctx.fill();\n            \n            // Body\n            ctx.fillRect(cx - shoulderWidth/2, enemyY + headSize * 2, shoulderWidth, bodyHeight);\n            \n            // Arms (swinging)\n            ctx.save();\n            ctx.translate(cx - shoulderWidth/2, enemyY + headSize * 2);\n            ctx.rotate(-armSwing);\n            ctx.fillRect(-enemyWidth*0.1, 0, enemyWidth*0.1, bodyHeight * 0.7);\n            ctx.restore();\n            \n            ctx.save();\n            ctx.translate(cx + shoulderWidth/2, enemyY + headSize * 2);\n            ctx.rotate(armSwing);\n            ctx.fillRect(0, 0, enemyWidth*0.1, bodyHeight * 0.7);\n            ctx.restore();\n            \n            // Legs (alternating)\n            const legSwing = Math.sin(enemyInView.animationPhase) * 0.15;\n            ctx.save();\n            ctx.translate(cx - shoulderWidth/4, enemyY + headSize * 2 + bodyHeight);\n            ctx.rotate(-legSwing);\n            ctx.fillRect(-shoulderWidth*0.1, 0, shoulderWidth*0.2, legHeight);\n            ctx.restore();\n            \n            ctx.save();\n            ctx.translate(cx + shoulderWidth/4, enemyY + headSize * 2 + bodyHeight);\n            ctx.rotate(legSwing);\n            ctx.fillRect(-shoulderWidth*0.1, 0, shoulderWidth*0.2, legHeight);\n            ctx.restore();\n            break;\n            \n        case 'chase':\n            // Aggressive chasing enemy with running animation\n            const runCycle = Math.sin(enemyInView.animationPhase * 2);\n            const runLean = Math.abs(runCycle) * 0.2;\n            \n            ctx.fillStyle = `rgba(${enemyInView.color.r},${enemyInView.color.g},${enemyInView.color.b},${0.8/(enemyDist)})`;\n            \n            // Add motion blur effect\n            ctx.fillStyle = `rgba(${enemyInView.color.r},${enemyInView.color.g},${enemyInView.color.b},${0.2/(enemyDist)})`;\n            ctx.fillRect(enemyX - enemyWidth/4, enemyY, enemyWidth * 1.5, enemyHeight);\n            \n            ctx.fillStyle = `rgba(${enemyInView.color.r},${enemyInView.color.g},${enemyInView.color.b},${0.8/(enemyDist)})`;\n            \n            // Tilted body for running pose\n            ctx.save();\n            ctx.translate(cx, enemyY + enemyHeight/2);\n            ctx.rotate(runLean);\n            \n            // Head\n            ctx.beginPath();\n            ctx.arc(0, -enemyHeight/2 + headSize, headSize, 0, Math.PI * 2);\n            ctx.fill();\n            \n            // Body\n            ctx.fillRect(-shoulderWidth/2, -enemyHeight/2 + headSize * 2, shoulderWidth, bodyHeight);\n            \n            // Arms (running motion)\n            const armRun = Math.sin(enemyInView.animationPhase * 2) * 0.5;\n            ctx.save();\n            ctx.translate(-shoulderWidth/2, -enemyHeight/2 + headSize * 2);\n            ctx.rotate(-armRun);\n            ctx.fillRect(-enemyWidth*0.1, 0, enemyWidth*0.1, bodyHeight * 0.7);\n            ctx.restore();\n            \n            ctx.save();\n            ctx.translate(shoulderWidth/2, -enemyHeight/2 + headSize * 2);\n            ctx.rotate(armRun);\n            ctx.fillRect(0, 0, enemyWidth*0.1, bodyHeight * 0.7);\n            ctx.restore();\n            \n            // Legs (running motion)\n            const legRun = Math.sin(enemyInView.animationPhase * 2) * 0.4;\n            ctx.save();\n            ctx.translate(-shoulderWidth/4, -enemyHeight/2 + headSize * 2 + bodyHeight);\n            ctx.rotate(-legRun);\n            ctx.fillRect(-shoulderWidth*0.1, 0, shoulderWidth*0.2, legHeight);\n            ctx.restore();\n            \n            ctx.save();\n            ctx.translate(shoulderWidth/4, -enemyHeight/2 + headSize * 2 + bodyHeight);\n            ctx.rotate(legRun);\n            ctx.fillRect(-shoulderWidth*0.1, 0, shoulderWidth*0.2, legHeight);\n            ctx.restore();\n            \n            ctx.restore();\n            break;\n    }\n}\n\n        // Draw floor and ceiling (unchanged)\n        let floorGradient = ctx.createLinearGradient(0, height - (height - h) / 2, 0, height);\n        floorGradient.addColorStop(0, 'rgba(255,0,0,0.2)');\n        floorGradient.addColorStop(1, 'rgba(0,0,0,0.2)');\n        ctx.fillStyle = floorGradient;\n        ctx.fillRect(divCount * dWidth, height - (height - h) / 2, dWidth, (height - h) / 2);\n\n        let ceilingGradient = ctx.createLinearGradient(0, 0, 0, (height - h) / 2);\n        ceilingGradient.addColorStop(0, 'rgba(20,20,20,0.2)');\n        ceilingGradient.addColorStop(1, 'rgba(255,0,0,0.2)');\n        ctx.fillStyle = ceilingGradient;\n        ctx.fillRect(divCount * dWidth, 0, dWidth, (height - h) / 2);\n\n        divCount++;\n    }\n    game.draw(topLeftX, topLeftY);\n}\n// Input handling\ndocument.addEventListener('keydown', (event) => {\n    if (!looping) {\n        requestAnimationFrame(gameLoop);\n        looping = true;\n    }\n    switch(event.keyCode) {\n        case 65: // A\n            player.rotateRight();\n            break;\n        case 68: // D\n            player.rotateLeft();\n            break;\n        case 38: // UP\n            advanceMove(player.moveForward.bind(player));\n            break;\n        case 40: // DOWN\n            advanceMove(player.moveBackward.bind(player));\n            break;\n        case 39: // RIGHT\n            advanceMove(player.moveRight.bind(player));\n            break;\n        case 37: // LEFT\n            advanceMove(player.moveLeft.bind(player));\n            break;\n        case 71: // G (changed from SPACE)\n            if (player.attack()) {  // Only trigger if attack() returns true\n                // Handle immediate attack effects\n                const attackArc = Math.PI / 2; // 90-degree attack arc\n                const attackRange = player.attackRange;\n                \n                for (const enemy of game.enemies) {\n                    const distanceToEnemy = dist(enemy.x, enemy.y, player.x, player.y);\n                    const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);\n                    let angleDiff = angleToEnemy - player.dir;\n                    \n                    // Normalize angle difference\n                    while (angleDiff > Math.PI) angleDiff -= TWO_PI;\n                    while (angleDiff < -Math.PI) angleDiff += TWO_PI;\n                    \n                    // Check if enemy is within attack range and angle\n                    if (distanceToEnemy <= attackRange && Math.abs(angleDiff) < attackArc / 2) {\n                        enemy.takeDamage(player.damage);\n                        \n                        // Add visual feedback - push enemy back slightly when hit\n                        const knockbackDistance = 0.5;\n                        const newX = enemy.x + Math.cos(angleToEnemy) * knockbackDistance;\n                        const newY = enemy.y + Math.sin(angleToEnemy) * knockbackDistance;\n                        \n                        if (!bumpingIntoWall(Math.floor(newX), Math.floor(newY))) {\n                            enemy.x = newX;\n                            enemy.y = newY;\n                        }\n                    }\n                }\n            }\n            break;\n    }\n});\n\ndocument.addEventListener('keyup', () => {\n    setTimeout(() => {\n        looping = false;\n    }, 2000);\n});\n// Game loop\nfunction gameLoop() {\n    draw();\n    if (looping) {\n        requestAnimationFrame(gameLoop);\n    }\n}\n// Start the game\nsetup();\ngameLoop();",
      "status": "[5]<br><span style=\"font-size:8px\">31ms<span></span></span>",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}