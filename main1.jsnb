{
  "metadata": {
    "name": "New JSNB",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dungeon Crawler</title>\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=Pirata+One&display=swap');\n        \n        body {\n            margin: 0;\n            font-family: 'MedievalSharp', cursive;\n            background: radial-gradient(circle at center, #2e0500, #100000);\n            color: white;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            overflow: hidden;\n            position: relative;\n           cursor:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADDklEQVR4nO2XT0gUYRiHf1qBaChCHYIuHbpEh4IgAqEuHVI7lp6CiAxq7ZCnuqzQoUN/wFBQyV1TbJetSGe2CNRG25l0pjkUbrAzqRWkO5O1a7VQueIbq7syu625C8F8xj7w3p/fO9/3zvsBBQoUKPCvCQTmKwOqWSUpRoOoGC2ibA4+5KfvgVWIqEiSzWZJNgVJNuckxSRr3R+YGnF5NQGsIirm1UzpVD3gpgW3VyeXV28Fi0iKeXo9+WSA82CNwMvwEVE2f60nn6gun34YLPF8fHaPJBvRXOSTAbaDFUbVTztE2Xyfq7zbq8+BFVR1plSSzfE85ImZCeTz0SZJNvvzkXcnyqM1gwUkxbidr7zLq7c4nVRstzsk2WjKS96jx11e7RxYQJLDtZJiLOYh/63bEzoGFhDluQOibMZyvrAe/aPbp+0DC4yOh3eJimnkPm301529+k6wgKpGKkTZnMj92GhPe3v1crCAqtIWUTGH8jg2nU5B2AxWVmNRNnpykXd5tCVmZvzfVuOs8l7th8sTqgPrq3H2zuufu3yhKrC+Gmc98x7tratvcrdtosThEPVj/3qrcfYLq0kdfaFt9snzqCceRByWyI/GtVbjNeR9bve7EtvkExCPK8sBkiEWH5ddkhRDzXyAZ1vIEtMJdkNPUE4cVGuI2eGzwpqdZ2khS0GDqCAOsjXEzNCZkSzy7CxkVsJNKIs2wh/vQdAa4s2jU6tHx+XRPtzxTu4Fa8w0oDRyAcNRByjqwNf43T9DMLWQZXY+4oCQlF+u6XoMxjrSQywMlDSB8c5ToiZPQgjWgII1mI+1p4cgDhftdgY5UZyD/Eodhz9zOpEf9j1KiMdN4rFIHLojDgxlyI9Y5SeqEQiewFbyozIthB8H7QzwPSXysw0vIg4sZOt8Sj7tP8HjMnGwd8skHrdWO5kI0YqxqTo8Szs21RBeHUUZWIQIRcSjzRriyzWMBWuwkK3zGytELQTm5dNCcOiwhkhcbGwkaOVLtFsCxFMjdsNAK1/iBnGIEY/rdvsUKFDgP+I3oaQkm96T7k8AAAAASUVORK5CYII='), auto;\n\n\n        }\n\n        .pattern-overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-image: url(\"data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0L60 30L30 60L0 30z' fill='none' stroke='%23784421' stroke-width='1' opacity='0.1'/%3E%3C/svg%3E\");\n            pointer-events: none;\n            z-index: 1;\n            opacity: 0.1;\n        }\n\n        #start-screen {\n            text-align: center;\n            position: relative;\n            padding: 60px;\n            z-index: 2;\n            background: rgba(0, 0, 0, 0.5);\n            border-radius: 15px;\n            border: 3px solid #945522;\n            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7), 0 0 40px #ffd700;\n        }\n\n        h1 {\n            font-family: 'Pirata One', cursive;\n            font-size: 6.5em;\n            margin: 0 0 30px;\n            color: #ffd700;\n            text-shadow: 4px 4px 8px rgba(0,0,0,0.7), 0 0 20px rgba(255,215,0,0.3), 0 0 40px rgba(255,215,0,0.2);\n        }\n\n        #start-button {\n            padding: 20px 50px;\n            font-size: 28px;\n            cursor: pointer;\n            border: 3px solid #784421;\n            background: linear-gradient(to bottom, #2a1810, #1a0f0a);\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n            text-transform: uppercase;\n            letter-spacing: 3px;\n            transition: all 0.4s ease;\n            clip-path: polygon(10% 0, 90% 0, 100% 50%, 90% 100%, 10% 100%, 0 50%);\n            position: relative;\n            overflow: hidden;\n            box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.1);\n        }\n\n        #start-button:hover {\n            transform: translateY(-3px) scale(1.05);\n            box-shadow: 0 8px 16px rgba(0,0,0,0.5), 0 0 30px rgba(255,215,0,0.2);\n            text-shadow: 0 0 10px rgba(255,215,0,0.5);\n            border-color: #945522;\n        }\n\n        #start-button:active {\n            transform: translateY(2px) scale(0.98);\n            box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 15px rgba(255,215,0,0.1);\n        }\n\n        .corner-decoration {\n            position: absolute;\n            width: 60px;\n            height: 60px;\n            background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M10,50 L30,20 L70,20 L90,50 L70,80 L30,80 Z' fill='%23784421' opacity='0.4'/%3E%3C/svg%3E\");\n            background-size: contain;\n            background-repeat: no-repeat;\n        }\n\n        .top-left { top: 20px; left: 20px; transform: rotate(0deg); }\n        .top-right { top: 20px; right: 20px; transform: rotate(90deg); }\n        .bottom-left { bottom: 20px; left: 20px; transform: rotate(270deg); }\n        .bottom-right { bottom: 20px; right: 20px; transform: rotate(180deg); }\n\n        #tooltip {\n            position: absolute;\n            display: none;\n            background: rgba(0, 0, 0, 0.8);\n            padding: 5px 10px;\n            border-radius: 5px;\n            font-size: 0.9em;\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n        }\n\n        /* Custom animations */\n        @keyframes flicker {\n            0% { opacity: 1; }\n            50% { opacity: 0.8; }\n            100% { opacity: 1; }\n        }\n        #start-screen { animation: flicker 3s infinite; }\n    </style>\n</head>\n<body>\n    <div class=\"pattern-overlay\"></div>\n    <div class=\"corner-decoration top-left\"></div>\n    <div class=\"corner-decoration top-right\"></div>\n    <div class=\"corner-decoration bottom-left\"></div>\n    <div class=\"corner-decoration bottom-right\"></div>\n    <div id=\"tooltip\">Click to enter the dungeon!</div>\n    <div id=\"start-screen\">\n        <h1>DUNGEON CRAWLER</h1>\n        <button id=\"start-button\">START GAME</button>\n    </div>\n    <div id=\"game-container\" style=\"display: none;\"></div>\n\n    <script>\n        const startButton = document.getElementById('start-button');\n        const tooltip = document.getElementById('tooltip');\n\n        // Show tooltip on button hover\n        startButton.addEventListener('mouseover', (e) => {\n            tooltip.style.display = 'block';\n            tooltip.style.left = e.pageX + 'px';\n            tooltip.style.top = e.pageY - 30 + 'px';\n        });\n\n        startButton.addEventListener('mousemove', (e) => {\n            tooltip.style.left = e.pageX + 'px';\n            tooltip.style.top = e.pageY - 30 + 'px';\n        });\n\n        startButton.addEventListener('mouseout', () => {\n            tooltip.style.display = 'none';\n        });\n\n        // Add hover sound effect\n       \n    </script>\n</body>\n</html>",
      "status": "",
      "output": "\n\n\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dungeon Crawler</title>\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=Pirata+One&display=swap');\n        \n        body {\n            margin: 0;\n            font-family: 'MedievalSharp', cursive;\n            background: radial-gradient(circle at center, #2e0500, #100000);\n            color: white;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            overflow: hidden;\n            position: relative;\n           cursor:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADDklEQVR4nO2XT0gUYRiHf1qBaChCHYIuHbpEh4IgAqEuHVI7lp6CiAxq7ZCnuqzQoUN/wFBQyV1TbJetSGe2CNRG25l0pjkUbrAzqRWkO5O1a7VQueIbq7syu625C8F8xj7w3p/fO9/3zvsBBQoUKPCvCQTmKwOqWSUpRoOoGC2ibA4+5KfvgVWIqEiSzWZJNgVJNuckxSRr3R+YGnF5NQGsIirm1UzpVD3gpgW3VyeXV28Fi0iKeXo9+WSA82CNwMvwEVE2f60nn6gun34YLPF8fHaPJBvRXOSTAbaDFUbVTztE2Xyfq7zbq8+BFVR1plSSzfE85ImZCeTz0SZJNvvzkXcnyqM1gwUkxbidr7zLq7c4nVRstzsk2WjKS96jx11e7RxYQJLDtZJiLOYh/63bEzoGFhDluQOibMZyvrAe/aPbp+0DC4yOh3eJimnkPm301529+k6wgKpGKkTZnMj92GhPe3v1crCAqtIWUTGH8jg2nU5B2AxWVmNRNnpykXd5tCVmZvzfVuOs8l7th8sTqgPrq3H2zuufu3yhKrC+Gmc98x7tratvcrdtosThEPVj/3qrcfYLq0kdfaFt9snzqCceRByWyI/GtVbjNeR9bve7EtvkExCPK8sBkiEWH5ddkhRDzXyAZ1vIEtMJdkNPUE4cVGuI2eGzwpqdZ2khS0GDqCAOsjXEzNCZkSzy7CxkVsJNKIs2wh/vQdAa4s2jU6tHx+XRPtzxTu4Fa8w0oDRyAcNRByjqwNf43T9DMLWQZXY+4oCQlF+u6XoMxjrSQywMlDSB8c5ToiZPQgjWgII1mI+1p4cgDhftdgY5UZyD/Eodhz9zOpEf9j1KiMdN4rFIHLojDgxlyI9Y5SeqEQiewFbyozIthB8H7QzwPSXysw0vIg4sZOt8Sj7tP8HjMnGwd8skHrdWO5kI0YqxqTo8Szs21RBeHUUZWIQIRcSjzRriyzWMBWuwkK3zGytELQTm5dNCcOiwhkhcbGwkaOVLtFsCxFMjdsNAK1/iBnGIEY/rdvsUKFDgP+I3oaQkm96T7k8AAAAASUVORK5CYII='), auto;\n\n\n        }\n\n        .pattern-overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-image: url(\"data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0L60 30L30 60L0 30z' fill='none' stroke='%23784421' stroke-width='1' opacity='0.1'/%3E%3C/svg%3E\");\n            pointer-events: none;\n            z-index: 1;\n            opacity: 0.1;\n        }\n\n        #start-screen {\n            text-align: center;\n            position: relative;\n            padding: 60px;\n            z-index: 2;\n            background: rgba(0, 0, 0, 0.5);\n            border-radius: 15px;\n            border: 3px solid #945522;\n            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7), 0 0 40px #ffd700;\n        }\n\n        h1 {\n            font-family: 'Pirata One', cursive;\n            font-size: 6.5em;\n            margin: 0 0 30px;\n            color: #ffd700;\n            text-shadow: 4px 4px 8px rgba(0,0,0,0.7), 0 0 20px rgba(255,215,0,0.3), 0 0 40px rgba(255,215,0,0.2);\n        }\n\n        #start-button {\n            padding: 20px 50px;\n            font-size: 28px;\n            cursor: pointer;\n            border: 3px solid #784421;\n            background: linear-gradient(to bottom, #2a1810, #1a0f0a);\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n            text-transform: uppercase;\n            letter-spacing: 3px;\n            transition: all 0.4s ease;\n            clip-path: polygon(10% 0, 90% 0, 100% 50%, 90% 100%, 10% 100%, 0 50%);\n            position: relative;\n            overflow: hidden;\n            box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.1);\n        }\n\n        #start-button:hover {\n            transform: translateY(-3px) scale(1.05);\n            box-shadow: 0 8px 16px rgba(0,0,0,0.5), 0 0 30px rgba(255,215,0,0.2);\n            text-shadow: 0 0 10px rgba(255,215,0,0.5);\n            border-color: #945522;\n        }\n\n        #start-button:active {\n            transform: translateY(2px) scale(0.98);\n            box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 15px rgba(255,215,0,0.1);\n        }\n\n        .corner-decoration {\n            position: absolute;\n            width: 60px;\n            height: 60px;\n            background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M10,50 L30,20 L70,20 L90,50 L70,80 L30,80 Z' fill='%23784421' opacity='0.4'/%3E%3C/svg%3E\");\n            background-size: contain;\n            background-repeat: no-repeat;\n        }\n\n        .top-left { top: 20px; left: 20px; transform: rotate(0deg); }\n        .top-right { top: 20px; right: 20px; transform: rotate(90deg); }\n        .bottom-left { bottom: 20px; left: 20px; transform: rotate(270deg); }\n        .bottom-right { bottom: 20px; right: 20px; transform: rotate(180deg); }\n\n        #tooltip {\n            position: absolute;\n            display: none;\n            background: rgba(0, 0, 0, 0.8);\n            padding: 5px 10px;\n            border-radius: 5px;\n            font-size: 0.9em;\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n        }\n\n        /* Custom animations */\n        @keyframes flicker {\n            0% { opacity: 1; }\n            50% { opacity: 0.8; }\n            100% { opacity: 1; }\n        }\n        #start-screen { animation: flicker 3s infinite; }\n    </style>\n\n\n    <div class=\"pattern-overlay\"></div>\n    <div class=\"corner-decoration top-left\"></div>\n    <div class=\"corner-decoration top-right\"></div>\n    <div class=\"corner-decoration bottom-left\"></div>\n    <div class=\"corner-decoration bottom-right\"></div>\n    <div id=\"tooltip\">Click to enter the dungeon!</div>\n    <div id=\"start-screen\" style=\"display: none;\">\n        <h1>DUNGEON CRAWLER</h1>\n        <button id=\"start-button\">START GAME</button>\n    </div>\n    <div id=\"game-container\" style=\"display: block;\"><canvas width=\"1000\" height=\"700\"></canvas></div>\n\n    <script>\n        const startButton = document.getElementById('start-button');\n        const tooltip = document.getElementById('tooltip');\n\n        // Show tooltip on button hover\n        startButton.addEventListener('mouseover', (e) => {\n            tooltip.style.display = 'block';\n            tooltip.style.left = e.pageX + 'px';\n            tooltip.style.top = e.pageY - 30 + 'px';\n        });\n\n        startButton.addEventListener('mousemove', (e) => {\n            tooltip.style.left = e.pageX + 'px';\n            tooltip.style.top = e.pageY - 30 + 'px';\n        });\n\n        startButton.addEventListener('mouseout', () => {\n            tooltip.style.display = 'none';\n        });\n\n        // Add hover sound effect\n       \n    </script>\n\n",
      "type": "html"
    },
    {
      "code": "const bgSound =  new Audio(\"https://github.com/Adam-Warlock09/Space-Invaders/blob/main/assets/sounds/bg.mp3?raw=true\")\nbgSound.loop = true\n\n//bg player\n\nbgSound.volume = 0.08\nbgSound.play()\n\n\n\nfunction startGame() {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.width = 1000;\n    canvas.height = 700;\n    document.getElementById('game-container').appendChild(canvas);\n\n    // Constants and setup\n    const TWO_PI = Math.PI * 2;\n    const PI = Math.PI;\n    const width = 1000;\n    const height = 700;\n    const rows = 70;\n    const cols = 100;\n    const viewAngle = 3.0 * Math.PI / 4.0;\n    const defaultColor = { r: 255, g: 12, b: 100 };\n    const qR = Math.PI / 30;\n    let game, player;    \n    let scaleX = 10;\n    let scaleY = 10;\n    let topLeftX = width - 220; // Move map to right side\n    let topLeftY = 20; // Add padding from top\n    let maxDiagonal = 1000;\n    let looping = true;\n    \n    // Combat constants\n    const ENEMY_COUNT = 5;\n    const PLAYER_MAX_HEALTH = 100;\n    const ENEMY_MAX_HEALTH = 50;\n    const ATTACK_RANGE = 5;\n    const ATTACK_DAMAGE = 20;\n    const ENEMY_DAMAGE = 2;\n    const ENEMY_ATTACK_COOLDOWN = 60;\n    let gameOver = false;\n\n    // Utility functions (keeping existing ones)\n    function random(min, max) { return Math.random() * (max - min) + min; }\n    function floor(n) { return Math.floor(n); }\n    function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)); }\n\n    // New Enemy class\n    class Enemy {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.health = ENEMY_MAX_HEALTH;\n        this.color = { r: 76, g: 153, b: 0 }; // Goblin green color\n        this.moveCounter = 0;\n        this.attackCooldown = 0;\n        this.attackAnimation = 0;\n        this.deathAnimation = 0;\n        this.isDying = false;\n        this.size = 1;\n        // Goblin features for more character-like appearance\n        this.features = {\n            ears: { x: 0.3, y: 0.2, size: 0.3 },\n            eyes: { x: 0.3, y: 0.4, size: 0.15 },\n            nose: { x: 0.5, y: 0.6, size: 0.2 }\n        };\n        this.animationFrame = 0;\n    }\n\n    update(player) {\n        if (this.isDying) {\n            this.deathAnimation++;\n            if (this.deathAnimation >= 30) {\n                return true; // Remove enemy\n            }\n            this.size = Math.max(0.2, 1 - (this.deathAnimation / 30));\n            this.color.g += 2; // Fade to yellow\n            return false;\n        }\n\n        // Animate goblin features\n        this.animationFrame = (this.animationFrame + 1) % 60;\n        this.features.ears.y = 0.2 + Math.sin(this.animationFrame * 0.1) * 0.05;\n        \n        // Update movement\n        this.moveCounter++;\n        if (this.moveCounter >= 30) {\n            this.moveCounter = 0;\n            this.moveTowardsPlayer(player);\n        }\n\n        // Update attack\n        if (this.attackCooldown > 0) {\n            this.attackCooldown--;\n            if (this.attackAnimation > 0) {\n                this.attackAnimation--;\n            }\n        } else {\n            // Attack player if in range\n            if (dist(this.x, this.y, player.x, player.y) < ATTACK_RANGE) {\n                player.takeDamage(ENEMY_DAMAGE);\n                this.attackCooldown = ENEMY_ATTACK_COOLDOWN;\n                this.attackAnimation = 10; // Start attack animation\n                \n                // Create attack effect\n                createAttackEffect(this.x, this.y, player.x, player.y);\n            }\n        }\n    }\n\n    moveTowardsPlayer(player) {\n        const dx = player.x - this.x;\n        const dy = player.y - this.y;\n        \n        // Simple pathfinding\n        let newX = this.x;\n        let newY = this.y;\n        \n        if (Math.abs(dx) > Math.abs(dy)) {\n            newX += Math.sign(dx);\n        } else {\n            newY += Math.sign(dy);\n        }\n\n        // Check if new position is valid\n        if (!bumpingIntoWall(newX, newY) && inBounds(newX, 0, cols - 1) && inBounds(newY, 0, rows - 1)) {\n            this.x = newX;\n            this.y = newY;\n        }\n    }\n\n    takeDamage(damage) {\n    this.health -= damage;\n    if (this.health <= 0) {\n        game.effects.push(new VisualEffect('death', this.x, this.y, 30));\n        return true;\n    }\n    game.effects.push(new VisualEffect('hit', this.x, this.y, 15));\n    return false;\n}\n\n    draw(game, topLeftX, topLeftY) {\n        const scale = this.size * game.scaleX;\n        const x = topLeftX + this.x * game.scaleX;\n        const y = topLeftY + this.y * game.scaleY;\n\n        if (this.isDying) {\n            // Draw death animation\n            ctx.fillStyle = `rgba(${this.color.r},${this.color.g},0,${1 - this.deathAnimation/30})`;\n            ctx.beginPath();\n            ctx.arc(x + scale/2, y + scale/2, scale * (1 - this.deathAnimation/30), 0, Math.PI * 2);\n            ctx.fill();\n            return;\n        }\n\n        // Draw goblin body\n        ctx.fillStyle = `rgb(${this.color.r},${this.color.g},${this.color.b})`;\n        ctx.fillRect(x, y, scale, scale);\n\n        // Draw goblin features\n        // Ears\n        ctx.fillStyle = 'rgb(50,100,0)';\n        ctx.beginPath();\n        ctx.arc(x + this.features.ears.x * scale, y + this.features.ears.y * scale, \n                this.features.ears.size * scale, 0, Math.PI * 2);\n        ctx.arc(x + (1 - this.features.ears.x) * scale, y + this.features.ears.y * scale, \n                this.features.ears.size * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Eyes\n        ctx.fillStyle = 'rgb(255,255,0)';\n        ctx.beginPath();\n        ctx.arc(x + this.features.eyes.x * scale, y + this.features.eyes.y * scale, \n                this.features.eyes.size * scale, 0, Math.PI * 2);\n        ctx.arc(x + (1 - this.features.eyes.x) * scale, y + this.features.eyes.y * scale, \n                this.features.eyes.size * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Nose\n        ctx.fillStyle = 'rgb(40,80,0)';\n        ctx.beginPath();\n        ctx.arc(x + this.features.nose.x * scale, y + this.features.nose.y * scale, \n                this.features.nose.size * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Attack animation\n        if (this.attackAnimation > 0) {\n            ctx.strokeStyle = 'rgba(255,0,0,0.5)';\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            ctx.arc(x + scale/2, y + scale/2, \n                    scale * (1 + this.attackAnimation/5), 0, Math.PI * 2);\n            ctx.stroke();\n        }\n\n        // Health bar\n        const healthBarWidth = scale;\n        const healthBarHeight = 2;\n        const healthPercentage = this.health / ENEMY_MAX_HEALTH;\n        \n        ctx.fillStyle = 'red';\n        ctx.fillRect(x, y - healthBarHeight - 1, healthBarWidth, healthBarHeight);\n        \n        ctx.fillStyle = 'green';\n        ctx.fillRect(x, y - healthBarHeight - 1, healthBarWidth * healthPercentage, healthBarHeight);\n    }\n}\n\n// Visual effects system\nconst effects = [];\n\nfunction createAttackEffect(startX, startY, endX, endY) {\n    effects.push({\n        type: 'attack',\n        startX: startX,\n        startY: startY,\n        endX: endX,\n        endY: endY,\n        duration: 10,\n        current: 0\n    });\n}\n\nfunction createDeathEffect(x, y) {\n    for (let i = 0; i < 8; i++) {\n        const angle = (Math.PI * 2 * i) / 8;\n        effects.push({\n            type: 'death',\n            x: x,\n            y: y,\n            dx: Math.cos(angle) * 0.2,\n            dy: Math.sin(angle) * 0.2,\n            duration: 30,\n            current: 0\n        });\n    }\n}\n\n  class VisualEffect {\n    constructor(type, x, y, duration) {\n        this.type = type;\n        this.x = x;\n        this.y = y;\n        this.duration = duration;\n        this.currentFrame = 0;\n        this.scale = 1;\n        this.opacity = 1;\n    }\n\n    update() {\n        this.currentFrame++;\n        const progress = this.currentFrame / this.duration;\n        \n        if (this.type === 'death') {\n            this.scale = 1 + progress;\n            this.opacity = 1 - progress;\n        } else if (this.type === 'hit') {\n            this.scale = 1 - progress * 0.5;\n            this.opacity = 1 - progress;\n        }\n        \n        return this.currentFrame < this.duration;\n    }\n\n    draw(ctx, cx, cy, w, h) {\n        ctx.save();\n        ctx.globalAlpha = this.opacity;\n        \n        if (this.type === 'death') {\n            // Explosion effect\n            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, w * this.scale);\n            gradient.addColorStop(0, 'rgba(255,255,0,0.8)');\n            gradient.addColorStop(0.6, 'rgba(255,100,0,0.5)');\n            gradient.addColorStop(1, 'rgba(255,0,0,0)');\n            \n            ctx.fillStyle = gradient;\n            ctx.beginPath();\n            ctx.arc(cx, cy, w * this.scale, 0, Math.PI * 2);\n            ctx.fill();\n        } else if (this.type === 'hit') {\n            // Hit effect\n            ctx.fillStyle = 'rgba(255,0,0,0.5)';\n            ctx.beginPath();\n            ctx.arc(cx, cy, w * this.scale, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        ctx.restore();\n    }\n}\n\n    // Enhanced Player class\n    class Player {\n        constructor(x, y, dir, options) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n            this.color = options ? (options.color ? options.color : defaultColor) : defaultColor;\n            this.health = PLAYER_MAX_HEALTH;\n            this.attackCooldown = 0;\n        }\n\n        // Keep all existing player methods...\n        modDir() {\n            this.dir = this.dir + 2 * TWO_PI;\n            this.dir = this.dir - (Math.floor(this.dir / TWO_PI) * TWO_PI);\n            if (this.dir < 0) this.dir = this.dir + TWO_PI;\n        }\n        \n        rotate(v) {\n            this.dir = this.dir + v;\n            this.modDir();\n        }\n        \n        rotateRight() {\n            this.rotate(-qR);\n        }\n        \n        rotateLeft() {\n            this.rotate(qR);\n        }\n        \n        move(vx, vy) {\n            this.x += vx;\n            this.y += vy;\n        }\n        \n        moveForward() {\n            if (this.dir <= PI / 8) this.move(1, 0);\n            else if (this.dir <= PI / 8 + PI / 4) this.move(1, 1);\n            else if (this.dir <= PI / 8 + PI / 2) this.move(0, 1);\n            else if (this.dir <= PI / 8 + 3 * PI / 4) this.move(-1, 1);\n            else if (this.dir <= PI / 8 + PI) this.move(-1, 0);\n            else if (this.dir <= PI / 8 + 5 * PI / 4) this.move(-1, -1);\n            else if (this.dir <= PI / 8 + 3 * PI / 2) this.move(0, -1);\n            else if (this.dir <= PI / 8 + 7 * PI / 4) this.move(1, -1);\n            else this.move(1, 0);\n        }\n        \n        moveBackward() {\n            let originalDir = this.dir;\n            this.dir += PI;\n            this.modDir();\n            this.moveForward();\n            this.dir = originalDir;\n        }\n        \n        moveLeft() {\n            let originalDir = this.dir;\n            this.dir += (-PI / 2);\n            this.modDir();\n            this.moveForward();\n            this.dir = originalDir;\n        }\n        \n        moveRight() {\n            let originalDir = this.dir;\n            this.dir += (PI / 2);\n            this.modDir();\n            this.moveForward();\n            this.dir = originalDir;\n        }\n\n        // New player methods\n        attack() {\n            if (this.attackCooldown > 0) return;\n            \n            // Attack enemies in range\n            for (let i = enemies.length - 1; i >= 0; i--) {\n                const enemy = enemies[i];\n                const distance = dist(this.x, this.y, enemy.x, enemy.y);\n                \n                if (distance < ATTACK_RANGE) {\n                    // Check if enemy is in player's view direction\n                    const angleToEnemy = Math.atan2(enemy.y - this.y, enemy.x - this.x);\n                    let angleDiff = Math.abs(angleToEnemy - this.dir);\n                    \n                    // Normalize angle difference\n                    if (angleDiff > Math.PI) {\n                        angleDiff = 2 * Math.PI - angleDiff;\n                    }\n                    \n                    // Attack if enemy is within view cone (120 degrees)\n                    if (angleDiff < Math.PI / 3) {\n                        if (enemy.takeDamage(ATTACK_DAMAGE)) {\n                            enemies.splice(i, 1); // Remove dead enemy\n                        }\n                    }\n                }\n            }\n            \n            this.attackCooldown = 20; // 20 frames cooldown\n        }\n\n        takeDamage(damage) {\n            if (this.damageImmunity > 0) return; // Don't take damage if immune\n            \n            this.health -= damage;\n            this.damageImmunity = 30; // Set immunity frames after taking damage\n            \n            if (this.health <= 0 && !gameOver) {\n                gameOver = true;\n                alert('Game Over! Press OK to restart.');\n                setup();\n            }\n        }\n\n        update() {\n            if (this.attackCooldown > 0) this.attackCooldown--;\n            if (this.damageImmunity > 0) this.damageImmunity--;\n        }\n    }\n\n    // Enhanced Game class\n    class Game {\n        constructor(width, height, rows, cols) {\n            this.width = width;\n            this.height = height;\n            this.cols = cols;\n            this.rows = rows;\n            this.scaleX = this.width / this.cols;\n            this.scaleY = this.height / this.rows;\n            this.design = [];\n\t\t    this.effects = [];\n            this.player = undefined;\n            for (let i = 0; i < this.rows; i++) {\n                let row = [];\n                for (let j = 0; j < this.cols; j++) {\n                    row.push(0);\n                }\n                this.design.push(row);\n            }\n        }\n\n\n        // Keep existing Game methods...\n        place(y, x, locations) {\n            if (!locations) this.design[y][x] = 1;\n            else for (let v of locations) {\n                this.design[v.y][v.x] = 1;\n            }\n        }\n\n        placeLine(y1, x1, y2, x2) {\n            if (y1 == y2) {\n                for (let j = Math.min(x1, x2); j <= Math.max(x1, x2); j++) {\n                    this.place(y1, j);\n                }\n            } else if (x1 == x2) {\n                for (let i = Math.min(y1, y2); i <= Math.max(y1, y2); i++) {\n                    this.place(i, x1);\n                }\n            }\n        }\n\n        addPlayer(player) {\n            this.player = player;\n\t\t}\n\n        // Enhanced draw method\n        draw(topLeftX, topLeftY) {\n            // Draw mini-map background\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent background\n            ctx.fillRect(topLeftX - 10, topLeftY - 10, this.width + 20, this.height + 20);\n            \n\t\t  // Update and draw effects\n\t\t    this.effects = this.effects.filter(effect => effect.update());\n\t\t\tthis.effects.forEach(effect => {\n\t\t\t\teffect.draw(ctx, \n\t\t\t\t\teffect.x * this.scaleX + this.scaleX/2, \n\t\t\t\t\teffect.y * this.scaleY + this.scaleY/2,\n\t\t\t\t\tthis.scaleX,\n\t\t\t\t\tthis.scaleY\n\t\t\t\t);\n\t\t\t});\n            // Draw game border\n            ctx.strokeStyle = 'white';\n            ctx.fillStyle = 'rgb(10,10,10)';\n            ctx.fillRect(topLeftX, topLeftY, this.width, this.height);\n            ctx.strokeRect(topLeftX, topLeftY, this.width, this.height);\n            \n            // Draw walls\n            for (let i = 0; i < this.rows; i++) {\n                for (let j = 0; j < this.cols; j++) {\n                    if (this.design[i][j] == 1) {\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(\n                            topLeftX + j * this.scaleX,\n                            topLeftY + i * this.scaleY,\n                            this.scaleX,\n                            this.scaleY\n                        );\n                    }\n                }\n            }\n\n            // Draw enemies\n            for (const enemy of enemies) {\n                enemy.draw(this, topLeftX, topLeftY);\n            }\n            \n            // Draw player\n            if (this.player) {\n                ctx.fillStyle = `rgb(${this.player.color.r},${this.player.color.g},${this.player.color.b})`;\n                ctx.fillRect(\n                    topLeftX + this.player.x * this.scaleX,\n                    topLeftY + this.player.y * this.scaleY,\n                    this.scaleX,\n                    this.scaleY\n                );\n\n                // Draw view rays\n                ctx.strokeStyle = 'rgba(200,200,200,0.15)';\n                for (let angle = this.player.dir - viewAngle / 2; angle <= this.player.dir + viewAngle / 2; angle += PI / 200) {\n                    let r = 50;\n                    ctx.beginPath();\n                    ctx.moveTo(\n                        topLeftX + this.player.x * this.scaleX + this.scaleX / 2,\n                        topLeftY + this.player.y * this.scaleY + this.scaleY / 2\n                    );\n                    ctx.lineTo(\n                        topLeftX + this.player.x * this.scaleX + this.scaleX / 2 + r * Math.cos(angle),\n                        topLeftY + this.player.y * this.scaleY + this.scaleY / 2 + r * Math.sin(angle)\n                    );\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n\n    // Enhanced helper functions\n    function spawnEnemy() {\n        let px, py;\n        let safeTries = 1000;\n        while (safeTries--) {\n            px = floor(random(0, cols - 1));\n            py = floor(random(0, rows - 1));\n            if (!bumpingIntoWall(px, py) && dist(px, py, player.x, player.y) > 10) {\n                return new Enemy(px, py);\n            }\n        }\n        return null;\n    }\n\n    // Keep existing helper functions...\n    function bumpingIntoWall(x, y) {\n        return game.design[y][x] !== 0;\n    }\n\n    function inBounds(v, low, high) {\n        return v <= high && v >= low;\n    }\n\n    // Enhanced setup function\n    function setup() {\n        game = new Game(width * 0.2, height * 0.2, rows, cols);\n        maxDiagonal = dist(0, 0, width * 0.2, height * 0.2);\n        setMap();\n        \n        // Spawn player\n        let px, py;\n        let safeTries = 1000;\n        while (safeTries--) {\n            px = floor(random(0, cols - 1));\n            py = floor(random(0, rows - 1));\n            if (!bumpingIntoWall(px, py)) break;\n        }\n        player = new Player(px, py, random(0, TWO_PI));\n        game.addPlayer(player);\n\n        // Spawn enemies\n        enemies = [];\n        for (let i = 0; i < ENEMY_COUNT; i++) {\n            const enemy = spawnEnemy();\n            if (enemy) enemies.push(enemy);\n        }\n\n        gameOver = false;\n    }\n\n    // Enhanced draw function\n function draw() {\n    ctx.fillStyle = 'rgb(22,22,22)';\n    ctx.fillRect(0, 0, width, height);\n\n    // Update game state\n    player.update();\n    for (const enemy of enemies) {\n        enemy.update(player);\n    }\n\n    let dAngle = PI / 200;\n    let noOfDivisions = floor(viewAngle / dAngle);\n    let dWidth = width / noOfDivisions;\n    let divCount = 0;\n\n    // Raycasting for walls and enemies\n    for (let angle = player.dir - viewAngle / 2; angle <= player.dir + viewAngle / 2; angle += dAngle) {\n        let d = maxDiagonal;\n        let hitEnemy = false;\n        let enemyDist = maxDiagonal;\n        let currentEnemy = null;\n\n        // Check for walls\n        for (let r = 0.1; r < maxDiagonal + 0.1; r += 0.1) {\n            let xx = player.x + (r * Math.cos(angle));\n            let yy = player.y + (r * Math.sin(angle));\n            \n            let gridX = floor(xx);\n            let gridY = floor(yy);\n            \n            if (!(inBounds(gridX, 0, cols - 1) && inBounds(gridY, 0, rows - 1))) {\n                break;\n            }\n            else if (inBounds(gridX, 0, cols - 1) && inBounds(gridY, 0, rows - 1) && game.design[gridY][gridX] === 1) {\n                d = dist(player.x, player.y, xx, yy);\n                break;\n            }\n\n            // Check for enemies with improved precision\n            for (const enemy of enemies) {\n                const enemyBoundingRadius = 0.5; // Half the enemy's width\n                const distToEnemy = dist(xx, yy, enemy.x + 0.5, enemy.y + 0.5);\n                \n                if (distToEnemy < enemyBoundingRadius) {\n                    let enemyD = dist(player.x, player.y, xx, yy);\n                    if (enemyD < d && (!hitEnemy || enemyD < enemyDist)) {\n                        hitEnemy = true;\n                        enemyDist = enemyD;\n                        currentEnemy = enemy;\n                    }\n                }\n            }\n        }\n\n        // Draw wall slice\n        let op = floor(255 / (Math.pow(d, 3 / 2)));\n        ctx.fillStyle = `rgba(255,255,255,${op/255})`;\n        let cx = divCount * dWidth + dWidth / 2;\n        let cy = height / 2;\n        let w = dWidth;\n        let h = height * (2 / (d * Math.pow(Math.cos(angle - player.dir), 1)));\n        ctx.fillRect(cx - w/2, cy - h/2, w, h);\n\n        // Draw enemy slice if visible with corrected perspective\n        if (hitEnemy && currentEnemy) {\n            const distanceFactor = Math.pow(Math.cos(angle - player.dir), 1);\n            op = floor(255 / (Math.pow(enemyDist, 3 / 2)));\n            h = height * (2 / (enemyDist * distanceFactor));\n            \n            // Draw basic goblin shape\n            ctx.fillStyle = `rgba(76,153,0,${op/255})`;\n            ctx.fillRect(cx - w/2, cy - h/2, w, h);\n            \n            // Draw goblin features only if close enough\n            if (enemyDist < 20) {\n                const featureOpacity = op/255;\n                const scale = h/100;\n                \n                // Eyes\n                ctx.fillStyle = `rgba(255,255,0,${featureOpacity})`;\n                const eyeSize = scale * 5;\n                const eyeOffset = w * 0.2;\n                ctx.beginPath();\n                ctx.arc(cx - eyeOffset, cy - h * 0.1, eyeSize, 0, TWO_PI);\n                ctx.arc(cx + eyeOffset, cy - h * 0.1, eyeSize, 0, TWO_PI);\n                ctx.fill();\n                \n                // Nose\n                ctx.fillStyle = `rgba(40,80,0,${featureOpacity})`;\n                ctx.beginPath();\n                ctx.arc(cx, cy, eyeSize * 0.8, 0, TWO_PI);\n                ctx.fill();\n            }\n            \n            // Health bar with corrected positioning\n            const healthBarWidth = w;\n            const healthBarHeight = Math.max(2, h * 0.03);\n            const healthPercentage = currentEnemy.health / ENEMY_MAX_HEALTH;\n            \n            ctx.fillStyle = `rgba(255,0,0,${op/255})`;\n            ctx.fillRect(cx - w/2, cy - h/2 - healthBarHeight * 2, healthBarWidth, healthBarHeight);\n            \n            ctx.fillStyle = `rgba(0,255,0,${op/255})`;\n            ctx.fillRect(cx - w/2, cy - h/2 - healthBarHeight * 2, healthBarWidth * healthPercentage, healthBarHeight);\n        }\n\n        // Continue with floor and ceiling rendering...\n        let floorGradient = ctx.createLinearGradient(0, height - (height - h) / 2, 0, height);\n        floorGradient.addColorStop(0, 'rgba(255,0,0,0.2)');\n        floorGradient.addColorStop(1, 'rgba(0,0,0,0.2)');\n        ctx.fillStyle = floorGradient;\n        ctx.fillRect(divCount * dWidth, height - (height - h) / 2, dWidth, (height - h) / 2);\n\n        let ceilingGradient = ctx.createLinearGradient(0, 0, 0, (height - h) / 2);\n        ceilingGradient.addColorStop(0, 'rgba(20,20,20,0.2)');\n        ceilingGradient.addColorStop(1, 'rgba(255,0,0,0.2)');\n        ctx.fillStyle = ceilingGradient;\n        ctx.fillRect(divCount * dWidth, 0, dWidth, (height - h) / 2);\n\n        divCount++;\n    }\n\t  effects.forEach((effect, index) => {\n        if (effect.current >= effect.duration) {\n            effects.splice(index, 1);\n            return;\n        }\n\n        if (effect.type === 'attack') {\n            const progress = effect.current / effect.duration;\n            const x = effect.startX + (effect.endX - effect.startX) * progress;\n            const y = effect.startY + (effect.endY - effect.startY) * progress;\n            \n            ctx.fillStyle = `rgba(255,0,0,${1-progress})`;\n            ctx.beginPath();\n            ctx.arc(topLeftX + x * scaleX, topLeftY + y * scaleY, \n                    5 * (1-progress), 0, Math.PI * 2);\n            ctx.fill();\n        } else if (effect.type === 'death') {\n            const progress = effect.current / effect.duration;\n            effect.x += effect.dx;\n            effect.y += effect.dy;\n            \n            ctx.fillStyle = `rgba(255,255,0,${1-progress})`;\n            ctx.beginPath();\n            ctx.arc(topLeftX + effect.x * scaleX, topLeftY + effect.y * scaleY, \n                    3 * (1-progress), 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        effect.current++;\n    });\n\n\n        // Draw 2D map view\n        game.draw(topLeftX, topLeftY);\n\n        // Draw UI elements with clear positioning\n        // Draw UI background\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(10, 10, 250, 100);\n        \n        // Draw health bar\n        const healthBarWidth = 200;\n        const healthBarHeight = 20;\n        const healthPercentage = player.health / PLAYER_MAX_HEALTH;\n        \n        ctx.fillStyle = 'white';\n        ctx.font = '16px Arial';\n        ctx.fillText(`Health: ${Math.ceil(player.health)}/${PLAYER_MAX_HEALTH}`, 20, 35);\n        \n        ctx.fillStyle = 'red';\n        ctx.fillRect(20, 45, healthBarWidth, healthBarHeight);\n        \n        ctx.fillStyle = 'green';\n        ctx.fillRect(20, 45, healthBarWidth * healthPercentage, healthBarHeight);\n\n        // Draw enemy count\n        ctx.fillStyle = 'white';\n        ctx.fillText(`Enemies Remaining: ${enemies.length}`, 20, 85);\n        \n        // Draw attack status\n        if (player.attackCooldown > 0) {\n            ctx.fillText(`Attack Cooldown: ${Math.ceil(player.attackCooldown/20 * 100)}%`, 20, 105);\n        } else {\n            ctx.fillText('Ready to Attack!', 20, 105);\n        }\n\n        // Draw victory message in center if applicable\n        if (enemies.length === 0) {\n            ctx.fillStyle = 'green';\n            ctx.font = '32px Arial';\n            const victoryText = 'Victory! All enemies defeated!';\n            const textMetrics = ctx.measureText(victoryText);\n            ctx.fillText(victoryText, (width - textMetrics.width) / 2, height/2);\n        }\n    }\n\n    // Enhanced input handling\n    document.addEventListener('keydown', (event) => {\n        if (!looping) {\n            requestAnimationFrame(gameLoop);\n            looping = true;\n        }\n        \n        if (gameOver) return;\n\n        switch(event.keyCode) {\n            case 65: // A\n                player.rotateRight();\n                break;\n            case 68: // D\n                player.rotateLeft();\n                break;\n            case 38: // UP\n                advanceMove(player.moveForward.bind(player));\n                break;\n            case 40: // DOWN\n                advanceMove(player.moveBackward.bind(player));\n                break;\n            case 39: // RIGHT\n                advanceMove(player.moveRight.bind(player));\n                break;\n            case 37: // LEFT\n                advanceMove(player.moveLeft.bind(player));\n                break;\n            case 32: // SPACE\n                player.attack();\n                break;\n        }\n    });\n\n    document.addEventListener('keyup', () => {\n        setTimeout(() => {\n            looping = false;\n        }, 2000);\n    });\n\n    // Keep existing helper functions\n    function advanceMove(move) {\n        let iX = player.x;\n        let iY = player.y;\n        move.call(player);\n        if (!inBounds(player.x, 0, cols - 1) || !inBounds(player.y, 0, rows - 1) || bumpingIntoWall(player.x, player.y)) {\n            player.x = iX;\n            player.y = iY;\n        }\n    }\n\n    function setMap() {\n        const lines = [\n            [10, 20, 10, 60],\n            [10, 70, 10, 90],\n            [10, 20, 55, 20],\n            [60, 20, 60, 40],\n            [60, 50, 60, 60],\n            [60, 60, 50, 60],\n            [40, 60, 30, 60],\n            [60, 60, 60, 70],\n            [60, 70, 60, 90],\n            [60, 90, 10, 90],\n            [40, 20, 40, 30],\n            [50, 35, 50, 40],\n            [45, 35, 50, 35],\n            [25, 30, 25, 40],\n            [25, 35, 45, 35],\n            [20, 40, 40, 40],\n            [50, 40, 60, 40],\n            [20, 45, 20, 65],\n            [20, 55, 35, 55],\n            [30, 50, 40, 50],\n            [40, 50, 40, 60],\n            [45, 80, 55, 80],\n            [50, 70, 60, 70],\n            [30, 75, 35, 75],\n            [20, 70, 30, 70],\n            [50, 85, 50, 90],\n            [30, 75, 30, 90],\n            [20, 70, 20, 90],\n            [40, 70, 40, 90],\n            [50, 0, 50, 10],\n            [55, 0, 55, 10],\n            [60, 0, 60, 10],\n            [65, 0, 65, 10],\n            [69, 0, 69, 99],\n            [0, 0, 69, 0],\n            [0, 0, 0, 99],\n            [0, 99, 69, 99]\n        ];\n           \n        for (let l of lines) {\n            game.placeLine(l[0], l[1], l[2], l[3]);\n        }\n    }\n\n    // Game loop\n    function gameLoop() {\n        draw();\n        if (looping) {\n            requestAnimationFrame(gameLoop);\n        }\n    }\n\n    // Start the game\n    setup();\n    gameLoop();\n}\n\n// Start button click event\ndocument.getElementById('start-button').addEventListener('click', () => {\n    document.getElementById('start-screen').style.display = 'none';\n    document.getElementById('game-container').style.display = 'block';\n    startGame();\n});",
      "status": "[1]<br><span style=\"font-size:8px\">0ms<span></span></span>",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}